%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                   Data                                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Observations and Analysis}\label{observations}

\begin{pycode}[manager_data]
manager_data = texfigure.Manager(
    pytex, './',
    python_dir='python',
    fig_dir='figures',
    data_dir='data',
    number=1,
)
\end{pycode}

% Describe data collection and prep procedures
% Can give brief description of timelag and em procedures, mostly just pointing to Paper 1

We analyze 12 hours of observations of \AR{} NOAA 1158 from the six EUV channels AIA beginning at and ending at . The \AR{} was chosen from the catalogue of \AR{} s originally compiled by \citet{warren_systematic_2012}. The data are at the full instrument cadence of 12 s and the full spatial resolution of 0.6\arcsec-per-pixel. The data were obtained from the JSOC archive using the data retrieval tools in the SunPy package \citep{sunpy_community_sunpypython_2015}.

\begin{pycode}[manager_data]
fits_files = [
    'aia_lev1.5_20110212T153238_94_cutout.fits',
    'aia_lev1.5_20110212T153245_131_cutout.fits',
    'aia_lev1.5_20110212T153248_171_cutout.fits',
    'aia_lev1.5_20110212T153243_193_cutout.fits',
    'aia_lev1.5_20110212T153248_211_cutout.fits',
    'aia_lev1.5_20110212T153239_335_cutout.fits',
]
fig = plt.figure(figsize=texfigure.figsize(
    pytex,
    scale=1 if is_onecolumn() else 2,
    height_ratio=2/3,
    figure_width_context='columnwidth'
))
plt.subplots_adjust(hspace=0.0,wspace=0.03)
for i,f in enumerate(fits_files):
    m = Map(os.path.join(manager_data.data_dir, 'observations', f))
    m = m.submap(SkyCoord(Tx=-440*u.arcsec,Ty=-380*u.arcsec,frame=m.coordinate_frame),
                 SkyCoord(Tx=-185*u.arcsec,Ty=-125*u.arcsec,frame=m.coordinate_frame))
    ax = fig.add_subplot(2,3,i+1,projection=m)
    norm = ImageNormalize(vmin=0, vmax=m.data.max(), stretch=SqrtStretch())
    m.plot(axes=ax, title=False, annotate=False, norm=norm)
    ax.grid(alpha=0)
    lon,lat = ax.coords
    lon.set_ticks(color='k',number=4)
    lat.set_ticks(color='k',number=4)
    if i != 3:
        lon.set_ticklabel_visible(False)
        lat.set_ticklabel_visible(False)
    else:
        lat.set_ticklabel(rotation='vertical')
        lon.set_axislabel('Helioprojective Longitude')
        lat.set_axislabel('Helioprojective Latitude')
    xtext,ytext = m.world_to_pixel(SkyCoord(-420*u.arcsec, -150*u.arcsec, frame=m.coordinate_frame))
    ax.text(
        xtext.value, ytext.value,
        f'{m.meta["wavelnth"]} $\mathrm{{\AA}}$',
        color='w',
        fontsize=plt.rcParams['legend.fontsize']
    )
fig_intensity_maps = manager_data.save_figure('intensity-maps')
fig_intensity_maps.caption = r'Maps of the observed intensity in all 6 EUV channels of AIA at a single point in time. The images of have been prepped, derotated, and cropped to \AR{} NOAA 1158.'
fig_intensity_maps.figure_env_name = 'figure*'
fig_intensity_maps.figure_width = r'\columnwidth' if is_onecolumn() else r'2\columnwidth'
fig_intensity_maps.fig_str = fig_str
\end{pycode}
\py[manager_data]|fig_intensity_maps|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                   EM Slopes                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Emission Measure Slopes}\label{em_slopes}

\begin{pycode}[manager_em]
manager_em = texfigure.Manager(
    pytex, './',
    python_dir='python',
    fig_dir='figures',
    data_dir='data',
    number=2,
)
from formatting import heating_palette
\end{pycode}

% Describe EM results, what we did specifically to get them
% show histograms of slopes as well as maps
% maybe have some comparison with models here, i.e. lay histograms on top of each other}

\begin{pycode}[manager_em]
fig = plt.figure(figsize=texfigure.figsize(
    pytex,
    scale=1 if is_onecolumn() else 2,
    height_ratio=1/2,
    figure_width_context='columnwidth'
))
plt.subplots_adjust(wspace=0.31)
### Map ###
slope_map = Map(os.path.join(manager_em.data_dir, 'observations', 'em_slope.fits'))
rsquared_map = Map(os.path.join(manager_em.data_dir, 'observations', 'em_slope_rsquared.fits'))
slope_map = Map(slope_map.data, slope_map.meta, mask=rsquared_map.data < rsquared_threshold)
slope_map = slope_map.submap(
    SkyCoord(Tx=-410*u.arcsec,Ty=-325*u.arcsec,frame=slope_map.coordinate_frame),
    SkyCoord(Tx=-225*u.arcsec,Ty=-150*u.arcsec,frame=slope_map.coordinate_frame))
ax = fig.add_subplot(121, projection=slope_map)
im = slope_map.plot(
    axes=ax,
    cmap='viridis',
    vmin=1.5,
    vmax=5.5,
    title=False,
    annotate=False
)
ax.grid(alpha=0)
# HPC Axes
lon,lat = ax.coords
lon.set_ticks(number=4)
lat.set_ticks(number=2)
lat.set_ticklabel(rotation='vertical')
lon.set_axislabel('Helioprojective Longitude',)
lat.set_axislabel('Helioprojective Latitude',)
# Colorbar
pos = ax.get_position().get_points()
cax = fig.add_axes([pos[0,0], pos[1,1]+0.01, pos[1,0]-pos[0,0], 0.025])
cbar = fig.colorbar(im,cax=cax, orientation='horizontal',)
cbar.ax.xaxis.set_ticks_position('top')
cbar.set_ticks([2,3,4,5])
### Histograms ###
ax = fig.add_subplot(122,)
bins = np.arange(0, 8, 0.05)
colors = ['k'] + heating_palette()
# Plot Model EM Slopes
for i,h in enumerate(['observations'] + heating):
    m = Map(os.path.join(manager_em.data_dir, f'{h}', 'em_slope.fits'))
    m_rsquared = Map(os.path.join(manager_em.data_dir, f'{h}', 'em_slope_rsquared.fits'))
    m = Map(m.data, m.meta, mask=m_rsquared.data < rsquared_threshold)
    h,b,_ = ax.hist(
        m.data[~m.mask],
        bins=bins,
        histtype='step',
        density=True,
        color=colors[i],
        label=h.split('_')[0].capitalize()
    )
# Ticks and Spines
ax.set_xlim(1, 8);
ax.xaxis.set_major_locator(FixedLocator([2, 3, 4, 5, 6, 7]))
ax.set_yticks(ax.get_yticks()[1:-1])
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['left'].set_bounds(ax.get_yticks()[0],ax.get_yticks()[-1])
ax.spines['bottom'].set_bounds(ax.get_xticks()[0],ax.get_xticks()[-1])
# Labels and legends
ax.set_xlabel(r'$a$')
ax.set_ylabel(r'Number of Pixels (Normalized)')
ax.legend(frameon=False,loc=1)
### Save ###
fig_em_slopes = manager_em.save_figure('em-slopes')
fig_em_slopes.caption = r'Left: Map of emission measure slope as computed from the time-averaged observed intensities. Right: Histogram of observed emission measure slope with model emission measure slopes overlaid.'
fig_em_slopes.figure_env_name = 'figure*'
fig_em_slopes.figure_width = r'\columnwidth' if is_onecolumn() else r'2\columnwidth'
fig_em_slopes.fig_str = fig_str
\end{pycode}
\py[manager_em]|fig_em_slopes|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                   Timelags                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Timelags}\label{timelags}

\begin{pycode}[manager_timelags]
manager_timelags = texfigure.Manager(
    pytex, './',
    python_dir='python',
    fig_dir='figures',
    data_dir='data',
    number=3,
)
file_format = os.path.join(manager_timelags.data_dir, 'observations', '{}_{}_{}.fits')
from synthesizAR.visualize import bgry_004_idl_cmap
\end{pycode}

\begin{pycode}[manager_timelags]
fig = plt.figure(figsize=texfigure.figsize(
    pytex,
    scale=1 if is_onecolumn() else 2,
    height_ratio=2.95/5,
    figure_width_context='columnwidth'
))
plot_params = {
    'title': False, 
    'annotate': False,
    'vmin': -(2*u.h).to(u.s).value,
    'vmax': (2*u.h).to(u.s).value,
    'cmap': bgry_004_idl_cmap,
}
axes = []
for i,cp in enumerate(channel_pairs):
    m = Map(file_format.format('timelag', *cp))
    mc = Map(file_format.format('correlation', *cp))
    m = Map(m.data, m.meta, mask=np.where(mc.data<=correlation_threshold, True, False))
    m = m.submap(SkyCoord(Tx=-440*u.arcsec,Ty=-380*u.arcsec,frame=m.coordinate_frame),
                 SkyCoord(Tx=-185*u.arcsec,Ty=-125*u.arcsec,frame=m.coordinate_frame))
    ax = fig.add_subplot(3, 5, i+1, projection=m)
    axes.append(ax)
    im = m.plot(axes=ax, **plot_params)
    ax.grid(alpha=0)
    lon = ax.coords[0]
    lat = ax.coords[1]
    lon.set_ticks(number=3)
    lat.set_ticks(number=3,) 
    if i == 5:
        lat.set_ticklabel(rotation='vertical',)
        lat.set_axislabel(r'Helioprojective Latitude',)
    else:
        lat.set_ticklabel_visible(False)
    if i == 11:
        lon.set_axislabel(r'Helioprojective Longitude')
    else:
        lon.set_ticklabel_visible(False)
    xtext,ytext = m.world_to_pixel(SkyCoord(-325*u.arcsec, -350*u.arcsec, frame=m.coordinate_frame))
    ax.text(
        xtext.value,ytext.value,
        '{}-{} $\mathrm{{\AA}}$'.format(*cp),
        color='k',
        fontsize=plt.rcParams['legend.fontsize']
    )
plt.subplots_adjust(wspace=0.03, hspace=0.03)
cax = fig.add_axes([
    axes[0].get_position().get_points()[0,0],
    axes[4].get_position().get_points()[1,1] + 0.01,
    axes[-1].get_position().get_points()[1,0] - axes[0].get_position().get_points()[0,0], 
    0.02
])
cbar = fig.colorbar(im, cax=cax, orientation='horizontal')
cbar.ax.xaxis.set_ticks_position('top')
fig_timelags = manager_timelags.save_figure('timelags')
fig_timelags.caption = r'Timelag maps as calculated from intensity data from observations of \AR{} NOAA 1158 by SDO/AIA. Timelag maps are shown for every possible channel pair as indicated in the upper left corner of each map. The colorbar range from -5000 s to +5000 s.'
fig_timelags.figure_env_name = 'figure*'
fig_timelags.figure_width = r'\columnwidth' if is_onecolumn() else r'2\columnwidth'
fig_timelags.fig_str = fig_str
\end{pycode}
\py[manager_timelags]|fig_timelags|

\begin{pycode}[manager_timelags]
fig = plt.figure(figsize=texfigure.figsize(
    pytex,
    scale=1 if is_onecolumn() else 2,
    height_ratio=2.95/5,
    figure_width_context='columnwidth'
))
plot_params = {
    'title': False, 
    'annotate': False,
    'vmin': 0,
    'vmax': 1,
    'cmap': 'magma',
}
axes = []
for i,cp in enumerate(channel_pairs):
    m = Map(file_format.format('correlation', *cp))
    m = m.submap(SkyCoord(Tx=-440*u.arcsec,Ty=-380*u.arcsec,frame=m.coordinate_frame),
                 SkyCoord(Tx=-185*u.arcsec,Ty=-125*u.arcsec,frame=m.coordinate_frame))
    ax = fig.add_subplot(3, 5, i+1, projection=m)
    axes.append(ax)
    im = m.plot(axes=ax, **plot_params)
    ax.grid(alpha=0)
    lon = ax.coords[0]
    lat = ax.coords[1]
    lon.set_ticks(number=3)
    lat.set_ticks(number=3,) 
    if i == 5:
        lat.set_ticklabel(rotation='vertical',)
        lat.set_axislabel(r'Helioprojective Latitude',)
    else:
        lat.set_ticklabel_visible(False)
    if i == 11:
        lon.set_axislabel(r'Helioprojective Longitude')
    else:
        lon.set_ticklabel_visible(False)
    xtext,ytext = m.world_to_pixel(SkyCoord(-420*u.arcsec, -150*u.arcsec, frame=m.coordinate_frame))
    ax.text(
        xtext.value,ytext.value,
        '{}-{} $\mathrm{{\AA}}$'.format(*cp),
        color='w',
        fontsize=plt.rcParams['legend.fontsize']
    )
plt.subplots_adjust(wspace=0.03, hspace=0.03)
cax = fig.add_axes([
    axes[0].get_position().get_points()[0,0],
    axes[4].get_position().get_points()[1,1] + 0.01,
    axes[-1].get_position().get_points()[1,0] - axes[0].get_position().get_points()[0,0], 
    0.02
])
cbar = fig.colorbar(im, cax=cax, orientation='horizontal')
cbar.ax.xaxis.set_ticks_position('top')
fig_correlations = manager_timelags.save_figure('correlations')
fig_correlations.caption = r'Same as \autoref{fig:timelags} except here we show the maximum value of the cross-correlation as derived from the observations.'
fig_correlations.figure_env_name = 'figure*'
fig_correlations.figure_width = r'\columnwidth' if is_onecolumn() else r'2\columnwidth'
fig_correlations.fig_str = fig_str
\end{pycode}
\py[manager_timelags]|fig_correlations|

\authorcomment2{Discussion of observed timelags and cross-correlation values}

\authorcomment2{Possibly put histograms of observations versus models here too}

\authorcomment1{Emphasize the point that no single heating model is consistent with the observations. Need multiple heating frequencies; this will lead into random forest stuff}